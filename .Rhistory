# sequence of PS from min to max with length m
grid <- seq(min(ps),max(ps),length=m)
# bandwidth
#h = diff(range(grid))/h
# out will hold model fits
out = list()
for (i in 1:m){
# weights
K = dnorm( (ps-grid[i])/h )
# exploratory: zero some weights out
K[ K < dnorm(1) ] = 0
# fit weighted quantile regression
# tau is the quantile to be estimated
# tau>1 estimates solution for all values of tau in (0,1)
# can include or exclude ps
out[[i]] = rq(y~a,tau=3 , weights=K)
}
return(list(out=out,ps=grid,h=h,y=y,a=a))
}
# plot quantile based mean
# out is "out" from my.localQ
# add option adds plot to previous plot
plot.Qmean <- function(out,add=F,...){
# because i am lazy
out.localQ=out
# estiamtes
delta = NULL
# propensity scores
x = NULL
# loop over grid of PS used in my.localQ
for (i in 1:length(out.localQ$out)){
delta = c(delta,sum(diff(out.localQ$out[[i]]$sol["tau",])*out.localQ$out[[i]]$sol["a",-ncol(out.localQ$out[[i]]$sol)]))
x = c(x,out.localQ$ps[i],length(out.localQ$out[[i]]$sol["a",]))
}
if (add){
lines(y=delta,x=out.localQ$ps,...)
}else{
plot(y=delta,x=out.localQ$ps,type='l',...)
}
}
# plot quantile
# out is "out" from my.localQ
# Y is the outcome
# X is the treatment
plot.Qavg <- function(out,Ytype="observedY0",...){
# set outcome and treatment
Y=out$y
X=out$a
# change the name -- because i am lazy
out.localQ <- out
# delta will hold effect estimates
delta = NULL
# q are the quantiles of Y(0)
q = NULL
# x is the propensity score
x = NULL
N = length(Y)
# loop over the grid of propensity scores used in my.localQ
for (i in 1:length(out.localQ$out)){
# weights used for the i-th quantile reg
K = out.localQ$out[[i]]$weights
if (Ytype=="observedY1"){
temp = wtd.quantile(Y[X==1],probs=out.localQ$out[[i]]$sol["tau",],weights=K[X==1])
q = c(q,temp)
ylab="Y1"
}
if (Ytype=="observedY0"){
temp = wtd.quantile(Y[X==0],probs=out.localQ$out[[i]]$sol["tau",],weights=K[X==0])
q = c(q,temp)
ylab = "Y0"
}
if (Ytype=="observedY"){
temp = wtd.quantile(Y,probs=out.localQ$out[[i]]$sol["tau",],weights=K)
q = c(q,temp)
ylab = "Y"
}
if (Ytype=="quantile"){
q = c(q,out.localQ$out[[i]]$sol["tau",])
}
# add estimates, quantiles, and PS to the output
delta = c(delta,out.localQ$out[[i]]$sol["a",])
x = c(x,rep(out.localQ$ps[i],length(out.localQ$out[[i]]$sol["a",])))
}
# might need to weight this based on observed PS dist?
qs=tapply(delta,round(q,2),mean)
plot(x=rownames(qs),y=qs,...)
}
# my heat map for local Q reg
# out is "out" from my.local Q
# Y is the outcome
# X is the treatment
heatmap.localQ <- function(out,Ytype="observedY0",...){
# set outcome and treatment
Y=out$y
X=out$a
if ( !(Ytype%in%c("observedY1","observedY0","observedY","quantile")) ){
print("Invalid Ytype")
return(NULL)
}
# because i am lazy
out.localQ <- out
# effect estimates
delta = NULL
# quantiles of Y0
q = NULL
# propensity scores
x = NULL
N = length(Y)
# this is the same as from plot.Qavg
for (i in 1:length(out.localQ$out)){
# weights used for the i-th quantile reg
K = out.localQ$out[[i]]$weights
#     if (!observedY & !observedY1){
#       # number of cutpoints from i-th quantile reg
#       M = length(out.localQ$out[[i]]$sol["tau",])
#       # initialize some matrices -- we want to output quantiles of
#       # Y(0), not the observed Y
#       Y0 = matrix(Y,N,M,byrow=F)
#       X0 = matrix(X,N,M,byrow=F)
#       # subtract out treatment effect
#       Y0 = Y0 - X0%*%diag(out.localQ$out[[i]]$sol["a",])
#       # bind the quantiles on top of the Y0 -- this is just so we can use apply
#       Y0 = rbind(out.localQ$out[[i]]$sol["tau",],Y0)
#       # find quantiles of Y0
#       temp = apply(Y0,2,function(x) wtd.quantile(x[-1],probs=x[1]))
#       q = c(q,temp)
#    }else{
if (Ytype=="observedY1"){
temp = wtd.quantile(Y[X==1],probs=out.localQ$out[[i]]$sol["tau",],weights=K[X==1])
q = c(q,temp)
ylab="Y1"
}
if (Ytype=="observedY0"){
temp = wtd.quantile(Y[X==0],probs=out.localQ$out[[i]]$sol["tau",],weights=K[X==0])
q = c(q,temp)
ylab = "Y0"
}
if (Ytype=="observedY"){
temp = wtd.quantile(Y,probs=out.localQ$out[[i]]$sol["tau",],weights=K)
q = c(q,temp)
ylab = "Y"
}
if (Ytype=="quantile"){
q = c(q,out.localQ$out[[i]]$sol["tau",])
}
# add estimates, quantiles, and PS to the output
delta = c(delta,out.localQ$out[[i]]$sol["a",])
x = c(x,rep(out.localQ$ps[i],length(out.localQ$out[[i]]$sol["a",])))
}
#col = rgb((delta<0)*abs(delta)/max(abs(delta)),0,(delta>0)*delta/max(delta),0.5)
index = q<Inf
col = heat.clr(delta[index])
plot(x=x[index],y=q[index],col=col,ylab=ylab,...)
}
# colors for heatmap
heat.clr = function(grid,color=c('red','white',"blue"),...){
clr1 = as.vector(grid)#-mean(grid)
clr.final = numeric(length(clr1))
c.max = max(abs(clr1))
c.min = min(abs(clr1))
clr2 = (clr1-c.min)/(c.max-c.min)
# for positives
index = clr1>0
shade = colorRamp(color[2:3])(clr2[index])
color.hex = rgb(shade,max=255)
clr.final[index] = color.hex
# for negatives
index = clr1<=0
shade = colorRamp(color[2:1])(-clr2[index])
color.hex = rgb(shade,max=255)
clr.final[index] = color.hex
return(clr.final)
}
# local ps regression
# loop over observations and do a weighted regression around that obs
library(survey)
localPSreg <- function(Y,ps,X,h){
V=beta=numeric(length(Y))
CI = matrix(0,length(Y),2)
for (i in 1:length(Y)){
h = diff(range(ps))/15
K = dnorm( (ps[i]-ps)/h )/dnorm(0)
dta = data.frame(Y=Y,X=X,K=K,ps=ps)
D <- svydesign(id = ~1, weights = ~K, data=dta)
M = svyglm(Y~X,D)
# could include PS as well:
# M = svyglm(Y~X+ps,D)
beta[i] = M$coef[2]
V[i] = vcov(M)[2,2]
CI[i,] = beta[i] + c(-1.96,1.96)*sqrt(V[i])
}
return(list(beta=beta,CI=CI,V=V))
}
# plot mean based on local regression
plot.localPS <- function(out,CI=F,add=F,...){
index = order(dta$ps)
ps = dta$ps[index]
beta.localPS <- out.localPS$beta[index]
if (CI){
CI.localPS <- out.localPS$CI[index,]
ylim = range(c(beta.localPS,CI.localPS))
if (add){
lines(ps,beta.localPS,ylim=ylim,...)
lines(ps,CI.localPS[,1],lty="dashed",col="grey")
lines(ps,CI.localPS[,2],lty="dashed",col="grey")
}else{
plot(ps,beta.localPS,type='l',ylim=ylim,...)
lines(ps,CI.localPS[,1],lty="dashed",col="grey")
lines(ps,CI.localPS[,2],lty="dashed",col="grey")
}
}else{
if (add){
lines(ps,beta.localPS,...)
}else{
plot(ps,beta.localPS,type='l',xlim=c(0,1),...)
}
}
}
out.localQ <- my.localQ(y=lalonde$re78,a=lalonde$treat,ps=lalonde$ps,h=5*h)
heatmap.localQ(out=out.localQ,Ytype="quantile",pch=16,xlab="PS")
rm(list=ls())
source("local_ATE_functions.r")
library(twang)
data(lalonde)
# fit the PS model
ps.lalonde <- ps(treat ~ age + educ + black + hispan + nodegree +
married + re74 + re75,
data = lalonde, stop.method=c("ks.max"),
estimand = "ATE",verbose=FALSE)
# save the ps
lalonde$ps = ps.lalonde$ps[,1]
# fit LoWePS-QR
h=dpill(x=lalonde$ps, y=lalonde$re78)
out.localQ <- my.localQ(y=lalonde$re78,a=lalonde$treat,ps=lalonde$ps,h=5*h)
# generate plots!
heatmap.localQ(out=out.localQ,Ytype="quantile",pch=16,xlab="PS")
plot.Qmean(out=out.localQ,add=F,col='blue')
plot.Qavg(out=out.localQ,Ytype="quantile",type='l',col='blue',xlab="quantile",ylab="Effect")
h
h*5
plot.Qavg(out=out.localQ,Ytype="quantile",type='l',col='blue',xlab="quantile of Y(0)",ylab="Effect")
heatmap.localQ(out=out.localQ,Ytype="quantile",pch=16,xlab="PS")
out.localQ <- my.localQ(y=lalonde$re78,a=lalonde$treat,ps=lalonde$ps,h=0.1)
heatmap.localQ(out=out.localQ,Ytype="quantile",pch=16,xlab="PS")
heatmap.localQ(out=out.localQ,Ytype="quantile",pch=16,xlab="PS",ylab="")
library(quantreg)
library(Hmisc)
library(KernSmooth)
# expit function
expit <- function(x) exp(x)/(1+exp(x))
# generate data
gen.dta <- function(n,a=c(0,0),b=c(0,0),bx.mult=0,bx.add=0,s2=1){
# generate covariate
C = rnorm(n)
# generate treatment
X = rbinom(n,1,expit(cbind(1,C)%*%a))
# coefs for outcome
Y0 = rnorm(n,cbind(1,C)%*%b,sqrt(s2))
Y1 = Y0*exp(bx.mult) + bx.add
# observed Y
Y = X*Y1 + (1-X)*Y0
return(data.frame(Y=Y,X=X,C=C,Y0=Y0,Y1=Y1))
}
# transform from PS to treatment effect
# NOT UP TO DATE!!!
f = function(p,a,b,bx) {
# x is really C
x = (log(p/(1-p))-a[1])/a[2]
Y1 = g(cbind(1,x,1,x^2)%*%b)*exp(bx)
Y0 = g(cbind(1,x,0,0)%*%b)
return(Y1-Y0)
}
# function to calculate ATE
# NOT UP TO DATE!!!!
ate = function(b) {
n = 1000000
C = rnorm(n)
Y1 = g(cbind(1,C,1,C)%*%b)
Y0 = g(cbind(1,C,0,0)%*%b)
return(mean(Y1-Y0))
}
# my local quantile regression
# y is outcome
# a is treatment
# ps is propensity score
# m is number of points on a grid for the PS
my.localQ <- function(y,a,ps,m=100,h=0.1){
# sequence of PS from min to max with length m
grid <- seq(min(ps),max(ps),length=m)
# bandwidth
#h = diff(range(grid))/h
# out will hold model fits
out = list()
for (i in 1:m){
# weights
K = dnorm( (ps-grid[i])/h )
# exploratory: zero some weights out
K[ K < dnorm(1) ] = 0
# fit weighted quantile regression
# tau is the quantile to be estimated
# tau>1 estimates solution for all values of tau in (0,1)
# can include or exclude ps
out[[i]] = rq(y~a,tau=3 , weights=K)
}
return(list(out=out,ps=grid,h=h,y=y,a=a))
}
# plot quantile based mean
# out is "out" from my.localQ
# add option adds plot to previous plot
plot.Qmean <- function(out,add=F,...){
# because i am lazy
out.localQ=out
# estiamtes
delta = NULL
# propensity scores
x = NULL
# loop over grid of PS used in my.localQ
for (i in 1:length(out.localQ$out)){
delta = c(delta,sum(diff(out.localQ$out[[i]]$sol["tau",])*out.localQ$out[[i]]$sol["a",-ncol(out.localQ$out[[i]]$sol)]))
x = c(x,out.localQ$ps[i],length(out.localQ$out[[i]]$sol["a",]))
}
if (add){
lines(y=delta,x=out.localQ$ps,...)
}else{
plot(y=delta,x=out.localQ$ps,type='l',...)
}
}
# plot quantile
# out is "out" from my.localQ
# Y is the outcome
# X is the treatment
plot.Qavg <- function(out,Ytype="observedY0",...){
# set outcome and treatment
Y=out$y
X=out$a
# change the name -- because i am lazy
out.localQ <- out
# delta will hold effect estimates
delta = NULL
# q are the quantiles of Y(0)
q = NULL
# x is the propensity score
x = NULL
N = length(Y)
# loop over the grid of propensity scores used in my.localQ
for (i in 1:length(out.localQ$out)){
# weights used for the i-th quantile reg
K = out.localQ$out[[i]]$weights
if (Ytype=="observedY1"){
temp = wtd.quantile(Y[X==1],probs=out.localQ$out[[i]]$sol["tau",],weights=K[X==1])
q = c(q,temp)
ylab="Y1"
}
if (Ytype=="observedY0"){
temp = wtd.quantile(Y[X==0],probs=out.localQ$out[[i]]$sol["tau",],weights=K[X==0])
q = c(q,temp)
ylab = "Y0"
}
if (Ytype=="observedY"){
temp = wtd.quantile(Y,probs=out.localQ$out[[i]]$sol["tau",],weights=K)
q = c(q,temp)
ylab = "Y"
}
if (Ytype=="quantile"){
q = c(q,out.localQ$out[[i]]$sol["tau",])
}
# add estimates, quantiles, and PS to the output
delta = c(delta,out.localQ$out[[i]]$sol["a",])
x = c(x,rep(out.localQ$ps[i],length(out.localQ$out[[i]]$sol["a",])))
}
# might need to weight this based on observed PS dist?
qs=tapply(delta,round(q,2),mean)
plot(x=rownames(qs),y=qs,...)
}
# my heat map for local Q reg
# out is "out" from my.local Q
# Y is the outcome
# X is the treatment
heatmap.localQ <- function(out,Ytype="observedY0",...){
# set outcome and treatment
Y=out$y
X=out$a
if ( !(Ytype%in%c("observedY1","observedY0","observedY","quantile")) ){
print("Invalid Ytype")
return(NULL)
}
# because i am lazy
out.localQ <- out
# effect estimates
delta = NULL
# quantiles of Y0
q = NULL
# propensity scores
x = NULL
N = length(Y)
# this is the same as from plot.Qavg
for (i in 1:length(out.localQ$out)){
# weights used for the i-th quantile reg
K = out.localQ$out[[i]]$weights
#     if (!observedY & !observedY1){
#       # number of cutpoints from i-th quantile reg
#       M = length(out.localQ$out[[i]]$sol["tau",])
#       # initialize some matrices -- we want to output quantiles of
#       # Y(0), not the observed Y
#       Y0 = matrix(Y,N,M,byrow=F)
#       X0 = matrix(X,N,M,byrow=F)
#       # subtract out treatment effect
#       Y0 = Y0 - X0%*%diag(out.localQ$out[[i]]$sol["a",])
#       # bind the quantiles on top of the Y0 -- this is just so we can use apply
#       Y0 = rbind(out.localQ$out[[i]]$sol["tau",],Y0)
#       # find quantiles of Y0
#       temp = apply(Y0,2,function(x) wtd.quantile(x[-1],probs=x[1]))
#       q = c(q,temp)
#    }else{
if (Ytype=="observedY1"){
temp = wtd.quantile(Y[X==1],probs=out.localQ$out[[i]]$sol["tau",],weights=K[X==1])
q = c(q,temp)
ylab="Y1"
}
if (Ytype=="observedY0"){
temp = wtd.quantile(Y[X==0],probs=out.localQ$out[[i]]$sol["tau",],weights=K[X==0])
q = c(q,temp)
ylab = "Y0"
}
if (Ytype=="observedY"){
temp = wtd.quantile(Y,probs=out.localQ$out[[i]]$sol["tau",],weights=K)
q = c(q,temp)
ylab = "Y"
}
if (Ytype=="quantile"){
q = c(q,out.localQ$out[[i]]$sol["tau",])
ylab = "quantile of Y(0)"
}
# add estimates, quantiles, and PS to the output
delta = c(delta,out.localQ$out[[i]]$sol["a",])
x = c(x,rep(out.localQ$ps[i],length(out.localQ$out[[i]]$sol["a",])))
}
#col = rgb((delta<0)*abs(delta)/max(abs(delta)),0,(delta>0)*delta/max(delta),0.5)
index = q<Inf
col = heat.clr(delta[index])
plot(x=x[index],y=q[index],col=col,ylab=ylab,...)
}
# colors for heatmap
heat.clr = function(grid,color=c('red','white',"blue"),...){
clr1 = as.vector(grid)#-mean(grid)
clr.final = numeric(length(clr1))
c.max = max(abs(clr1))
c.min = min(abs(clr1))
clr2 = (clr1-c.min)/(c.max-c.min)
# for positives
index = clr1>0
shade = colorRamp(color[2:3])(clr2[index])
color.hex = rgb(shade,max=255)
clr.final[index] = color.hex
# for negatives
index = clr1<=0
shade = colorRamp(color[2:1])(-clr2[index])
color.hex = rgb(shade,max=255)
clr.final[index] = color.hex
return(clr.final)
}
# local ps regression
# loop over observations and do a weighted regression around that obs
library(survey)
localPSreg <- function(Y,ps,X,h){
V=beta=numeric(length(Y))
CI = matrix(0,length(Y),2)
for (i in 1:length(Y)){
h = diff(range(ps))/15
K = dnorm( (ps[i]-ps)/h )/dnorm(0)
dta = data.frame(Y=Y,X=X,K=K,ps=ps)
D <- svydesign(id = ~1, weights = ~K, data=dta)
M = svyglm(Y~X,D)
# could include PS as well:
# M = svyglm(Y~X+ps,D)
beta[i] = M$coef[2]
V[i] = vcov(M)[2,2]
CI[i,] = beta[i] + c(-1.96,1.96)*sqrt(V[i])
}
return(list(beta=beta,CI=CI,V=V))
}
# plot mean based on local regression
plot.localPS <- function(out,CI=F,add=F,...){
index = order(dta$ps)
ps = dta$ps[index]
beta.localPS <- out.localPS$beta[index]
if (CI){
CI.localPS <- out.localPS$CI[index,]
ylim = range(c(beta.localPS,CI.localPS))
if (add){
lines(ps,beta.localPS,ylim=ylim,...)
lines(ps,CI.localPS[,1],lty="dashed",col="grey")
lines(ps,CI.localPS[,2],lty="dashed",col="grey")
}else{
plot(ps,beta.localPS,type='l',ylim=ylim,...)
lines(ps,CI.localPS[,1],lty="dashed",col="grey")
lines(ps,CI.localPS[,2],lty="dashed",col="grey")
}
}else{
if (add){
lines(ps,beta.localPS,...)
}else{
plot(ps,beta.localPS,type='l',xlim=c(0,1),...)
}
}
}
heatmap.localQ(out=out.localQ,Ytype="quantile",pch=16,xlab="PS",ylab="")
heatmap.localQ(out=out.localQ,Ytype="quantile",pch=16,xlab="PS")
plot.Qmean(out=out.localQ,add=F,col='blue')
plot.Qmean(out=out.localQ,add=F,col='blue',xlab="PS")
plot.Qmean(out=out.localQ,add=F,col='blue',xlab="PS",ylab="Effect")
plot.Qavg(out=out.localQ,Ytype="quantile",type='l',col='blue',xlab="quantile of Y(0)",ylab="Effect")
