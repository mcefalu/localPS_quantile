{
    "contents" : "############################\n###    LoWePS functions  ### \n##\n## Last modification: add comments / clean code\n## Date: 08/28/15\n## By: M Cefalu\n\n###############################\n### load required packages  ### \nlibrary(quantreg)\nlibrary(Hmisc)\nlibrary(KernSmooth)\nlibrary(survey)\n\n\n\n####################################\n### my local quantile regression ###\n##\n## y is outcome\n## a is treatment\n## ps is propensity score\n## m is number of points on a grid for the PS\n\nmy.localQ <- function(y,a,ps,m=100,h=0.1){\n  # sequence of PS from min to max PS with length m\n  grid <- seq(min(ps),max(ps),length=m)\n  # bandwidth -- currently specified by user\n  #h = diff(range(grid))/h\n  \n  # out holds the quantile regression fits for each point in the PS grid\n  out = list()\n  for (i in 1:m){\n    # weights\n    K = dnorm( (ps-grid[i])/h )\n    # exploratory: zero some weights out\n    K[ K < dnorm(1) ] = 0 \n    \n    ######################################\n    ## fit weighted quantile regression ##\n    # tau is the quantile to be estimated\n    # tau>1 estimates solution for all values of tau in (0,1)\n    out[[i]] = rq(y~a,tau=3 , weights=K)\n  }\n  # return the fits, the PS grid, the bandwidth, the outcomes , and the treatments\n  return(list(out=out,ps=grid,h=h,y=y,a=a))\n}\n\n\n\n\n###########################################\n### plot mean as a function of PS based ###\n### on local quantile regressions       ###\n##\n## out is \"out\" from my.localQ\n## add option adds plot to previous plot\n## everything else is passed through to plot\n\nplot.Qmean <- function(fit,add=F,...){\n  # delta saves estiamtes of the mean\n  delta = NULL\n  # loop over grid of PS used in my.localQ\n  for (i in 1:length(fit$out)){\n    # add estimates of the mean\n    # the mean is just the integral of the quantile function\n    # for each PS, the quantile function is a step function\n    # so we just add up the estimates, weighting by the width between quantile points\n    delta = c(delta,sum(diff(fit$out[[i]]$sol[\"tau\",])*fit$out[[i]]$sol[\"a\",-ncol(fit$out[[i]]$sol)]))\n  }\n  # now plot\n  if (add){\n    lines(y=delta,x=fit$ps,...)\n  }else{\n    plot(y=delta,x=fit$ps,type='l',...)\n  }\n}\n\n\n\n\n#######################################\n### plot marginal quantile function ###\n##\n## fit is \"out\" from my.localQ\n## Ytype defines how we plot the x-axis.\n\nplot.Qavg <- function(fit,Ytype=\"observedY0\",...){\n  # set outcome and treatment\n  Y=fit$y\n  X=fit$a\n  # delta will hold effect estimates\n  delta = NULL\n  # q are the quantiles of Y(0) or Y(1), or just the quantile itself\n  q = NULL\n  # x is the propensity score\n  x = NULL\n  N = length(Y)\n  \n  # loop over the grid of propensity scores used in my.localQ\n  for (i in 1:length(fit$out)){\n    # weights used for the i-th quantile reg\n    K = fit$out[[i]]$weights\n    # check ytype -- it changes what we save in q\n    if (Ytype==\"observedY1\"){\n      temp = wtd.quantile(Y[X==1],probs=fit$out[[i]]$sol[\"tau\",],weights=K[X==1])\n      q = c(q,temp)\n    }\n    if (Ytype==\"observedY0\"){\n      temp = wtd.quantile(Y[X==0],probs=fit$out[[i]]$sol[\"tau\",],weights=K[X==0])\n      q = c(q,temp)\n    }\n    if (Ytype==\"observedY\"){\n      temp = wtd.quantile(Y,probs=fit$out[[i]]$sol[\"tau\",],weights=K)\n      q = c(q,temp)\n    }\n    if (Ytype==\"quantile\"){\n      q = c(q,fit$out[[i]]$sol[\"tau\",])\n    }\n    # add estimates and PS to the output\n    delta = c(delta,fit$out[[i]]$sol[\"a\",])\n    x = c(x,rep(fit$ps[i],length(fit$out[[i]]$sol[\"a\",])))\n  }\n  # might need to weight this based on observed PS dist?\n  qs=tapply(delta,round(q,2),mean)\n  plot(x=rownames(qs),y=qs,...)\n}\n\n\n\n\n\n###############################\n###  heat map for my.localQ ###\n##\n## fit is \"out\" from my.local Q\n## Ytype defines how we plot the y-axis.\n\nheatmap.localQ <- function(fit,Ytype=\"observedY0\",...){\n  # set outcome and treatment\n  Y=fit$y\n  X=fit$a\n  # check that ytype is valid\n  if ( !(Ytype%in%c(\"observedY1\",\"observedY0\",\"observedY\",\"quantile\")) ){\n    print(\"Invalid Ytype\")\n    return(NULL)\n  }\n  # effect estimates\n  delta = NULL\n  # quantiles of Y0\n  q = NULL\n  # propensity scores\n  x = NULL\n  N = length(Y)\n  # this code is the same as from plot.Qavg\n  for (i in 1:length(fit$out)){\n    # weights used for the i-th quantile reg\n    K = fit$out[[i]]$weights\n    # check ytype -- it changes what we save in q\n    if (Ytype==\"observedY1\"){\n      temp = wtd.quantile(Y[X==1],probs=fit$out[[i]]$sol[\"tau\",],weights=K[X==1])\n      q = c(q,temp)\n      ylab=\"Y1\"\n    }\n    if (Ytype==\"observedY0\"){\n      temp = wtd.quantile(Y[X==0],probs=fit$out[[i]]$sol[\"tau\",],weights=K[X==0])\n      q = c(q,temp)\n      ylab = \"Y0\"\n    }\n    if (Ytype==\"observedY\"){\n      temp = wtd.quantile(Y,probs=fit$out[[i]]$sol[\"tau\",],weights=K)\n      q = c(q,temp)\n      ylab = \"Y\"\n    }\n    if (Ytype==\"quantile\"){\n      q = c(q,fit$out[[i]]$sol[\"tau\",])\n      ylab = \"quantile of Y(0)\"\n    }\n    # add estimates and PS to the output\n    delta = c(delta,fit$out[[i]]$sol[\"a\",])\n    x = c(x,rep(fit$ps[i],length(fit$out[[i]]$sol[\"a\",])))\n  }\n  # plot! \n  index = q<Inf\n  col = heat.clr(delta[index])\n  plot(x=x[index],y=q[index],col=col,ylab=ylab,...)\n}\n\n\n\n\n\n##########################\n### colors for heatmap ###\n##\n## grid is the values to be plotted\n## color is 3 color system. First color is negative, second zero, third positive\n\nheat.clr = function(grid,color=c('red','white',\"blue\"),...){\n  clr1 = as.vector(grid)#-mean(grid)\n  clr.final = numeric(length(clr1))\n  c.max = max(abs(clr1))\n  c.min = min(abs(clr1))\n  clr2 = (clr1-c.min)/(c.max-c.min)\n  # for positives\n  index = clr1>0\n  shade = colorRamp(color[2:3])(clr2[index])\n  color.hex = rgb(shade,max=255)\n  clr.final[index] = color.hex\n  # for negatives\n  index = clr1<=0\n  shade = colorRamp(color[2:1])(-clr2[index])\n  color.hex = rgb(shade,max=255)\n  clr.final[index] = color.hex\n  return(clr.final)\n}\n\n\n\n\n###########################\n### local ps regression ###\n## \n## Y is outcome\n## X is treatment\n## ps is propensity score\n## h is bandwidth\n\nlocalPSreg <- function(Y,ps,X,h=.1){\n  V=beta=numeric(length(Y))\n  CI = matrix(0,length(Y),2)\n  # loop over observations and do a weighted regression around that obs\n  for (i in 1:length(Y)){\n    # bandwidth -- user specified for now\n    #h = diff(range(ps))/15\n    # weights\n    K = dnorm( (ps[i]-ps)/h )/dnorm(0) \n    # fit the model\n    dta = data.frame(Y=Y,X=X,K=K,ps=ps)\n    D <- svydesign(id = ~1, weights = ~K, data=dta)\n    M = svyglm(Y~X,D)\n    # save output\n    beta[i] = M$coef[2]\n    V[i] = vcov(M)[2,2]\n    CI[i,] = beta[i] + c(-1.96,1.96)*sqrt(V[i])\n  }\n  return(list(beta=beta,CI=CI,V=V))\n}\n\n\n\n#####################################\n### plot mean based on localPSreg ###\n##\n## fit is output of localPSreg\n## CI specifies whether or not to plot CIs\n## add specifies whether or not to add to existing figure\n## everything else passed to plot\n\nplot.localPS <- function(out,CI=F,add=F,...){\n  # this code is broken!!!\n  index = order(dta$ps)\n  ps = dta$ps[index]\n  beta.localPS <- out.localPS$beta[index]\n  if (CI){\n    CI.localPS <- out.localPS$CI[index,]\n    ylim = range(c(beta.localPS,CI.localPS))\n    if (add){\n      lines(ps,beta.localPS,ylim=ylim,...)\n      lines(ps,CI.localPS[,1],lty=\"dashed\",col=\"grey\")\n      lines(ps,CI.localPS[,2],lty=\"dashed\",col=\"grey\")\n    }else{\n      plot(ps,beta.localPS,type='l',ylim=ylim,...)\n      lines(ps,CI.localPS[,1],lty=\"dashed\",col=\"grey\")\n      lines(ps,CI.localPS[,2],lty=\"dashed\",col=\"grey\")\n    }\n  }else{\n    if (add){\n      lines(ps,beta.localPS,...)\n    }else{\n      plot(ps,beta.localPS,type='l',xlim=c(0,1),...)\n    }\n  }\n}\n",
    "created" : 1440780215736.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4019352063",
    "id" : "46803595",
    "lastKnownWriteTime" : 1440785621,
    "path" : "~/Documents/Research/Methods/Causal Inference/LoWePS/code/source/local_ATE_functions.r",
    "project_path" : "code/source/local_ATE_functions.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}